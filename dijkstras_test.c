#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>


typedef struct {
	int vertex;
	int weight;
} edge_t;

typedef struct {
	edge_t **edges;
	int edges_len;
	int edges_size;
	int dist;
	int prev;
	int visited;
} vertex_t;

typedef struct {
	vertex_t **vertices;
	int vertices_len;
	int vertices_size;
} graph_t;

typedef struct {
	int *data;
	int *prio;
	int *index;
	int len;
	int size;
} heap_t;


//FUNCTIONS FOR DIJKSTRAS HERE
void add_vertex(graph_t *g, int i);
void add_edge(graph_t *g, int a, int b, int w);
heap_t *create_heap(int n);
void push_heap(heap_t *h, int v, int p);
int minimum(heap_t *h, int i, int j, int k);
int pop_heap(heap_t *h);
//dijkstra(g,source_v,destination_v)
void dijkstra(graph_t *g, int a, int b);
//print_path(g,destination_v) The print path function updates variables path_to_goal and path length with the current shortest path generated by dijkstras function
void print_path(graph_t *g, int i);
//generate an undirected edge in a graph. source vertex, destination vertex, weight
void generate_undirected_edge(graph_t *g, int source, int destination, int weight);
//function which prints out the contents of the path_to_goal array
void print_ptg();
//initialize the graph. this is a test function
void init_graph(graph_t *g);
//high level function which returns shortest path given source vertex and destination vertex. updates path_to_goal and path_length variables
void compute_shortest_path(int source, int destination);
//function which generates a grid representation of the world, given a 1-d cost array generated from a map
void generate_grid(graph_t *g);
//map visualiser would print out the map in the command window
void map_visualiser();

//VARIABLES FOR DIJKSTRAS HERE
//array of chars which contains the shortest path from source vertex to destination vertex
int path_to_goal[300];
// integer which indicates the number of vertices in the shortest path
int path_length = 0;
//global graph g
graph_t *g;


# define MAP_WIDTH 4
# define MAP_HEIGHT 3


//cost array. false=free space. true=obstacle
bool cost_array[12] = { false,true,false,false,false,true,false,false,false,false,false,false };


int main() {

	/* ok

	compute_shortest_path('a', 'e');
	compute_shortest_path('a', 'c');
	*/
	/*
	for (int i = 0; i < 100; i++) {
	printf("%d\n", cost_array[i]);
	}
	*/
	compute_shortest_path(0, 2);

	getch();
	return 0;
}

void map_visualiser() {
	// @ represents the generated path
	// # represents the obstacle
	// . represents free space
	char map[MAP_WIDTH][MAP_HEIGHT];

	//firstly, we will fill up all elements as free space
	for (int y = 0; y < MAP_HEIGHT; y++) {
		for (int x = 0; x < MAP_WIDTH; x++) {
			map[x][y] = '.';

		}// bracket of x loop

	}// bracket of y loop

	 //Next, we will fill up the map with obstacles
	for (int y = 0; y < MAP_HEIGHT; y++) {
		for (int x = 0; x < MAP_WIDTH; x++) {
			//Firstly, we will look up the index given current x and y
			int i = x + MAP_WIDTH*y;
			//if its a obstacle, change the element to a #. else do nothing
			if (cost_array[i] == true) { map[x][y] = '#'; }

		}// bracket of x loop

	}// bracket of y loop

	 //next, we will fill up the map with the generated path.
	for (int i = 0; i < path_length; i++) {
		//firstly, we will obtain the index of the path vertex
		int p_index = path_to_goal[i];
		//next, we will obtain the corresponding x and y coord of the path
		int p_x = p_index%MAP_WIDTH;
		int p_y = p_index / MAP_WIDTH;
		printf("%d %d\n", p_x, p_y);
		//we would want to update the map with the path info
		map[p_x][p_y] = '@';
	}

	 //lastly, we will print out the elements in the map
	for (int y = MAP_HEIGHT - 1; y >= 0; y--) {
		for (int x = 0; x < MAP_WIDTH; x++) {
			printf("%c ", map[x][y]);

		}//bracket of x loop
		printf("\n");
	}//bracket of y loop

}


void generate_grid(graph_t *g) {
	//map height and map width are not base 0. height(y-direction) width(x-direction)
	const static int map_height = 3;
	const static int map_width = 4;
	const static int obstacle_cost = 1000;
	const static int freespace_cost = 1;

	//generate grid
	for (int y = 0; y < map_height; y++) {
		for (int x = 0; x < map_width; x++) {
			//Firstly, we would compute the current 1-d index given the current xy coords
			int curr_index = x + (map_width*y);
			//if the current vertex is an obstacle vertex, set all edges to neighbouring verticies as obstacles
			if (cost_array[curr_index] == true) {
				//compute edge to right neighbouring vertex
				if ((x + 1) < map_width) {
					//add_edge(g, curr_index, curr_index+1,obstacle_cost);
				}
				//compute edge to left neighbouring vertex
				if ((x - 1) >= 0) {
					//add_edge(g, curr_index, curr_index - 1, obstacle_cost);
				}
				//compute edge to top neighbouring vertex
				if ((y + 1) < map_height) {
					//we will compute index of top neighbouring vertex
					int top_index = x + (map_width*(y + 1));
					add_edge(g, curr_index, top_index, obstacle_cost);

				}
				//compute edge to bottom neighbouring vertex
				if ((y - 1) >= 0) {
					//we will compute index of bottom neighbouring vertex
					int bottom_index = x + (map_width*(y - 1));
					add_edge(g, curr_index, bottom_index, obstacle_cost);

				}
			}//bracket of obstacle true

			 //if the current vertex is not an obstacle, then we examine the neighbouring vertex costs, and determine if the edges are free or not
			if (cost_array[curr_index] == false) {
				//compute edge to right neighbouring vertex
				if ((x + 1) < map_width) {
					//if the right neighbouring vertex is also free , then set a free cost
					if (cost_array[curr_index + 1] == false) { add_edge(g, curr_index, curr_index + 1, freespace_cost); }
					else { add_edge(g, curr_index, curr_index + 1, obstacle_cost); }

				}
				//compute edge to left neighbouring vertex
				if ((x - 1) >= 0) {
					//if the left neighbouring vertex is also free , then set a free cost
					if (cost_array[curr_index - 1] == false) { add_edge(g, curr_index, curr_index - 1, freespace_cost); }
					else { add_edge(g, curr_index, curr_index - 1, obstacle_cost); }

				}
				//compute edge to top neighbouring vertex
				if ((y + 1) < map_height) {
					//we will compute index of top neighbouring vertex
					int top_index = x + (map_width*(y + 1));
					//if the top neighbouring vertex is also free , then set a free cost
					if (cost_array[top_index] == false) { add_edge(g, curr_index, top_index, freespace_cost); }
					else { add_edge(g, curr_index, top_index, obstacle_cost); }


				}
				//compute edge to bottom neighbouring vertex
				if ((y - 1) >= 0) {
					//we will compute index of bottom neighbouring vertex
					int bottom_index = x + (map_width*(y - 1));
					//if the bottom neighbouring vertex is also free , then set a free cost
					if (cost_array[bottom_index] == false) { add_edge(g, curr_index, bottom_index, freespace_cost); }
					else { add_edge(g, curr_index, bottom_index, obstacle_cost); }


				}

			}//bracket of obstacle false
		}//bracket of x

	}//bracket of y

}


void print_ptg() {
	for (int i = 0; i < path_length; i++) {
		printf("%d\n", path_to_goal[i]);
	}
}

void init_graph(graph_t *g) {
	// we would initialise the graph. this only needs to be done once. graph used is the reference graph in the medium.com post
	generate_undirected_edge(g, 'a', 'c', 3);
	generate_undirected_edge(g, 'a', 'b', 7);
	generate_undirected_edge(g, 'b', 'c', 1);
	generate_undirected_edge(g, 'c', 'd', 2);
	generate_undirected_edge(g, 'b', 'd', 2);
	generate_undirected_edge(g, 'b', 'e', 6);
	generate_undirected_edge(g, 'd', 'e', 4);
}


void compute_shortest_path(int source, int destination) {
	static bool init = false;
	if (init == false) {
		//init g pointer
		g = calloc(1, sizeof(graph_t));
		//init graph
		generate_grid(g);
		init = true;
	}
	//compute dijkstras
	dijkstra(g, source, destination);
	//compute path
	print_path(g, destination);
	//print_ptg for debugging purposes.
	print_ptg();
	//visualise the map for debugging purposes.
	map_visualiser();

}

void generate_undirected_edge(graph_t *g, int source, int destination, int weight) {
	add_edge(g, source, destination, weight);
	add_edge(g, destination, source, weight);
}

void add_vertex(graph_t *g, int i) {
	if (g->vertices_size < i + 1) {
		int size = g->vertices_size * 2 > i ? g->vertices_size * 2 : i + 4;
		g->vertices = realloc(g->vertices, size * sizeof(vertex_t *));
		for (int j = g->vertices_size; j < size; j++)
			g->vertices[j] = NULL;
		g->vertices_size = size;
	}
	if (!g->vertices[i]) {
		g->vertices[i] = calloc(1, sizeof(vertex_t));
		g->vertices_len++;
	}
}

void add_edge(graph_t *g, int a, int b, int w) {
	add_vertex(g, a);
	add_vertex(g, b);
	vertex_t *v = g->vertices[a];
	if (v->edges_len >= v->edges_size) {
		v->edges_size = v->edges_size ? v->edges_size * 2 : 4;
		v->edges = realloc(v->edges, v->edges_size * sizeof(edge_t *));
	}
	edge_t *e = calloc(1, sizeof(edge_t));
	e->vertex = b;
	e->weight = w;
	v->edges[v->edges_len++] = e;
}

heap_t *create_heap(int n) {
	heap_t *h = calloc(1, sizeof(heap_t));
	h->data = calloc(n + 1, sizeof(int));
	h->prio = calloc(n + 1, sizeof(int));
	h->index = calloc(n, sizeof(int));
	return h;
}

void push_heap(heap_t *h, int v, int p) {
	int i = h->index[v] == 0 ? ++h->len : h->index[v];
	int j = i / 2;
	while (i > 1) {
		if (h->prio[j] < p)
			break;
		h->data[i] = h->data[j];
		h->prio[i] = h->prio[j];
		h->index[h->data[i]] = i;
		i = j;
		j = j / 2;
	}
	h->data[i] = v;
	h->prio[i] = p;
	h->index[v] = i;
}

int minimum(heap_t *h, int i, int j, int k) {
	int m = i;
	if (j <= h->len && h->prio[j] < h->prio[m])
		m = j;
	if (k <= h->len && h->prio[k] < h->prio[m])
		m = k;
	return m;
}

int pop_heap(heap_t *h) {
	int v = h->data[1];
	int i = 1;
	while (1) {
		int j = minimum(h, h->len, 2 * i, 2 * i + 1);
		if (j == h->len)
			break;
		h->data[i] = h->data[j];
		h->prio[i] = h->prio[j];
		h->index[h->data[i]] = i;
		i = j;
	}
	h->data[i] = h->data[h->len];
	h->prio[i] = h->prio[h->len];
	h->index[h->data[i]] = i;
	h->len--;
	return v;
}

void dijkstra(graph_t *g, int a, int b) {
	int i, j;
	for (i = 0; i < g->vertices_len; i++) {
		vertex_t *v = g->vertices[i];
		v->dist = INT_MAX;
		v->prev = 0;
		v->visited = 0;
	}
	vertex_t *v = g->vertices[a];
	v->dist = 0;
	heap_t *h = create_heap(g->vertices_len);
	push_heap(h, a, v->dist);
	while (h->len) {
		i = pop_heap(h);
		if (i == b)
			break;
		v = g->vertices[i];
		v->visited = 1;
		for (j = 0; j < v->edges_len; j++) {
			edge_t *e = v->edges[j];
			vertex_t *u = g->vertices[e->vertex];
			if (!u->visited && v->dist + e->weight <= u->dist) {
				u->prev = i;
				u->dist = v->dist + e->weight;
				push_heap(h, e->vertex, u->dist);
			}
		}
	}
}

void print_path(graph_t *g, int i) {
	int n, j;
	vertex_t *v, *u;

	v = g->vertices[i];
	if (v->dist == INT_MAX) {
		printf("no path\n");
		return;
	}
	//n refers to the no. of vertices in the path
	//u->dist refers to the total cost of the path
	//the path array stores the path information. first element is the source vertex. last element is the destination vertex.
	for (n = 1, u = v; u->dist; u = g->vertices[u->prev], n++);
	char *path = malloc(n);
	path[n - 1] = i;
	//this line populates the path array with path info
	for (j = 0, u = v; u->dist; u = g->vertices[u->prev], j++) {
		path[n - j - 2] = u->prev;
	}
	//this line, the path array has been populated.
	for (int i = 0; i < n; i++) {
		path_to_goal[i] = path[i];
	}
	path_length = n;
}
